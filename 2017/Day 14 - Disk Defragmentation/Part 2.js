// Declare the necessary variables
var fs = require("fs"),
	input = "oundnydw";

// Given a hexadecimal value this converts it to binary.
var hex2bin = hex => {
    return ("00000000" + (parseInt(hex, 16)).toString(2)).substr(-8);
};

// Given a string this returns the corresponding knot hash.
var knot = str => {
	var position = 0,
		skip = 0,
		commands = [],
		list = [],
		hash = [];
	for(var k = 0; k < str.length; k++) { commands[k] = str[k].charCodeAt(0); }
	commands.push(17, 31, 73, 47, 23);
	for(var i = 0; i < 256; i++) { list[i] = i; }
	for(var i = 0; i < 64; i++) {
	    for(const length of commands) {
	        if(length > 1) {
	            list = list.slice(position).concat(list.slice(0, position));
	            list = list.slice(0, length).reverse().concat(list.slice(length));
	            list = list.slice(-position).concat(list.slice(0, -position));
	        }
	        position = (position + length + skip++) % 256;
	    }
	}
	for(var i = 0; i < 16; i++) {
	    const iter = list.slice(i * 16, i * 16 + 16).reduce((a, b) => a ^ b);
	    hash.push(iter);
	}
	var zeropadding = input => ("0" + input).substr(-2);
	return hash.map(elem => zeropadding(elem.toString(16))).join("");
};

// For a given position in the grid this counts the number of elements in the group containing the starting position.
var step = (pos, grid, counted, counter) => {
	if(counted.findIndex(elem => elem.x == pos.x && elem.y == pos.y + 1) == -1 && pos.y < 127 && grid[pos.y + 1][pos.x] == "1") {
		counted.push({x: pos.x, y: pos.y + 1});
		counter += step({x: pos.x, y: pos.y + 1}, grid, counted, 0);
		counter++;
	}
	if(counted.findIndex(elem => elem.x == pos.x && elem.y == pos.y - 1) == -1 && pos.y > 0 && grid[pos.y - 1][pos.x] == "1") {
		counted.push({x: pos.x, y: pos.y - 1});
		counter += step({x: pos.x, y: pos.y - 1}, grid, counted, 0);
		counter++;
	}
	if(counted.findIndex(elem => elem.x == pos.x + 1 && elem.y == pos.y) == -1 && pos.x < 127 && grid[pos.y][pos.x + 1] == "1") {
		counted.push({x: pos.x + 1, y: pos.y});
		counter += step({x: pos.x + 1, y: pos.y}, grid, counted, 0);
		counter++;
	}
	if(counted.findIndex(elem => elem.x == pos.x - 1 && elem.y == pos.y) == -1 && pos.x > 0 && grid[pos.y][pos.x - 1] == "1") {
		counted.push({x: pos.x - 1, y: pos.y});
		counter += step({x: pos.x - 1, y: pos.y}, grid, counted, 0);
		counter++;
	}
	return counter;
};

// Main function that iterates through the grid until all elements have been checked and outputs the number of distinct groups. 
var main = () => {
	var arr = [],
		sizes = [],
		counted = [];
	var TMP = [];
	for(var i = 0; i < 128; i++) {
		var hash = knot(input + "-" + i),
			bin = "";
		for(var j = 0; j < hash.length; j++) {
			bin += hex2bin(hash[j]).slice(hex2bin(hash[j]).length - 4);
		}
		TMP.push(bin);
		arr.push(bin.split(""));
	}
	for(var i = 0; i < 128; i++) {
		if(counted.length == 128 * 128) { break; }
		for(var j = 0; j < 128; j++) {
			if(arr[i][j] == "1" && counted.findIndex(elem => elem.x == j && elem.y == i) == -1) {
				sizes.push(step({x: j, y: i}, arr, counted, 0));
			}
			else if(arr[i][j] == "0") { counted.push({x: j, y: i}); }
		}
	}
	console.log("The number of distinct groups in the grid generated by the key string " + input + " is " + sizes.length + ".");
};

main();